
<!-- saved from url=(0055)http://train.usaco.org/usacotext2?a=bhbgPYsGoPP&S=euler -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>欧拉回路 Eulerian Tour
</title>
</head><body bgcolor="#f0f0f0">
<font face="Verdana,Tahoma,sans-serif,Arial,Lucida Sans,Gill Sans">
<div style="width:45em;background-color:white;border-style:solid;border-width:1px;padding:1em;">
<table cellspacing="8">
   <tbody><tr><td><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/cowhead2.gif"></td>
       <td>&nbsp;&nbsp;&nbsp;</td>
       <td><b><font size="5">
	<font face="Verdana,Tahoma,sans-serif,Arial,Lucida Sans,Gill Sans">
	欧拉路径 <br /> Eulerian Tour
</font></font></b></td>
   </tr>
</tbody></table>

<h4>示例题目：骑马修栅栏</h4>

<p>Farmer John拥有许多的栅栏，他必须时常检查它们是否完好无损。Farmer John通过保存一个栅栏相连顶点的列表来追踪他的栅栏。每个栅栏都有两个端点，每个端点位于一个交叉点，尽管交叉点可能只是一个栅栏的端点。当然，两个以上的栅栏可能共享一个端点。

</p><p>给出栅栏布局，计算是否存在一种方案使Farmer John经过所有的栅栏，而不经过同一栅栏两次。Farmer John可以在任意位置开始和结束，但不能穿过他的田地（他在交叉点间穿行的唯一方法是栅栏）。如果存在一种方案，找到它。

</p><h4>抽象化</h4>

<p>给定：一个无向图

</p><p>找到一条只使用每条边恰好一次的路径。这被称为欧拉路径。如果路径的起点和终点相同，则这被称为欧拉回路。

</p><h4>算法</h4>

<p>判断一个图是否存在欧拉路径或欧拉回路其实很简单；有两个规则。

</p><ul>

<li>一个图存在欧拉回路，当且仅当它是联通的（在把所有度为0的节点删除以后），且所有节点的度均为偶数。</li>

<li>一个图存在欧拉路径，当且仅当它是联通的，且除特定的2个节点外所有节点的度均为偶数。</li>

<li>在第二种情况下，度为奇数的两个节点必须有一个为起点，另一个为终点。</li>

</ul>

<p>初始的想法是从一些节点开始并The basic idea of the algorithm is to start at some node the
graph and determine a circuit back to that same node.  Now, as the
circuit is added (in reverse order, as it turns out), the algorithm
ensures that all the edges of all the nodes along that path have
been used.  If there is some node along that path which has an edge
that has not been used, then the algorithm finds a circuit starting
at that node which uses that edge and splices this new circuit into
the current one.  This continues until all the edges of every node
in the original circuit have been used, which, since the graph is
connected, implies that all the edges have been used, so the
resulting circuit is Eulerian.

</p><p> More formally, to determine a Eulerian circuit of a graph which has
one, pick a starting node and recurse on it.  At each recursive step:

</p><ul>

<li> Pick a starting node and recurse on that node.  At each step:</li>

<ul type="square">

<li> If the node has no neighbors, then append the node to the
circuit and return

</li><li> If the node has a neighbor, then make a list of the neighbors and process
them (which includes deleting them from the list of nodes on which to
work) until the node has no more neighbors</li>

<li> To process a node, delete the edge between the current node and its
neighbor, recurse on the neighbor, and postpend the current node to the
circuit.</li>

</ul>

</ul>

伪代码：
<pre># circuit 是一个全局数组
   find_euler_circuit
     circuitpos = 0
     find_circuit(node 1)

# nextnode and visited 是一个局部数组
# 路径将会以反向顺序被找到
  find_circuit(node i)

    if node i has no neighbors then
      circuit(circuitpos) = node i
      circuitpos = circuitpos + 1
    else
      while (node i has neighbors)
          pick a random neighbor node j of node i
          delete_edges (node j, node i)
          find_circuit (node j)
      circuit(circuitpos) = node i
      circuitpos = circuitpos + 1
</pre>

<p> 要To find an Eulerian tour, simply find one of the nodes which has
odd degree and call <tt><font size="2"> find_circuit</font></tt> with
it.

</p><p> Both of these algorithms run in O(m + n) time, where m is the number
of edges and n is the number of nodes, if you store the graph in
adjacency list form.  With larger graphs, there's a danger of
overflowing the run-time stack, so you might have to use your own stack.

</p><h4>Execution Example</h4>

<p> Consider the following graph: <br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler1.gif"><br>

</p><p>Assume that selecting a random neighbor yields the lowest numbered
neighbor, the execution goes as follows:

<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2a.gif"><br>
</td>
<td> Stack:  <br> Location: 1 <br> Circuit: </td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2b.gif"><br>
</td>
<td> Stack: 1 <br> Location: 4 <br> Circuit: </td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2c.gif"><br>
</td>
<td> Stack: 1 4 <br> Location: 2 <br> Circuit: </td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2d.gif"><br>
</td>
<td> Stack: 1 4 2 <br> Location: 5 <br> Circuit: </td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2e.gif"><br>
</td>
<td> Stack: 1 4 2 5 <br> Location: 1 <br> Circuit: </td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2e.gif"><br>
</td>
<td> Stack: 1 4 2 <br> Location: 5 <br> Circuit: 1</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2f.gif"><br>
</td>
<td> Stack: 1 4 2 5 <br> Location: 6 <br> Circuit: 1</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2g.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 <br> Location: 2 <br> Circuit: 1</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2h.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 <br> Location: 7 <br> Circuit: 1</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2i.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 7 <br> Location: 3 <br> Circuit: 1</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2j.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 7 3 <br> Location: 4 <br> Circuit: 1</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2k.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 7 3 4 <br> Location: 6 <br> Circuit: 1</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2l.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 7 3 4 6 <br> Location: 7 <br> Circuit: 1</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 7 3 4 6 7 <br> Location: 5 <br> Circuit: 1</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 7 3 4 6 <br> Location: 7 <br> Circuit: 1 5</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 7 3 4 <br> Location: 6 <br> Circuit: 1 5 7</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 7 3 <br> Location: 4 <br> Circuit: 1 5 7 6</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 7 <br> Location: 3 <br> Circuit: 1 5 7 6 4</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 2 <br> Location: 7 <br> Circuit: 1 5 7 6 4 3</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 2 5 6 <br> Location: 2 <br> Circuit: 1 5 7 6 4 3 7</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 2 5 <br> Location: 6 <br> Circuit: 1 5 7 6 4 3 7 2</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 2 <br> Location: 5 <br> Circuit: 1 5 7 6 4 3 7 2 6</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 4 <br> Location: 2 <br> Circuit: 1 5 7 6 4 3 7 2 6 5</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack: 1 <br> Location: 4 <br> Circuit: 1 5 7 6 4 3 7 2 6 5 2</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>
</td>
<td> Stack:  <br> Location: 1 <br> Circuit: 1 5 7 6 4 3 7 2 6 5 2 4</td></tr>
</tbody></table>
<table> <tbody><tr> <td><br><img src="./&#27431;&#25289;&#22238;&#36335; Eulerian Tour_files/euler2m.gif"><br>

</td>
<td> Stack:  <br> Location:  <br> Circuit: 1 5 7 6 4 3 7 2 6 5 2 4 1</td></tr>
</tbody></table>

</p><h4>Extensions</h4>

<p> Multiple edges between nodes can be handled by the exact same algorithm.

</p><p> Self-loops can be handled by the exact same algorithm as well, if
self-loops are considered to add 2 (one in and one out) to the degree
of a node.

</p><p> A directed graph has a Eulerian circuit if it is strongly
connected (except for nodes with both in-degree and out-degree of
0) and the indegree of each node equals its outdegree.  The algorithm
is exactly the same, except that because of the way this code finds
the cycle, you must traverse arcs in reverse order.

</p><p> Finding a Eulerian path in a directed graph is harder.  Consult Sedgewick
if you are interested.

</p><h4>Example problems </h4>

<h5>Airplane Hopping</h5>

<p> Given a collection of cities, along with the flights between
those cities, determine if there is a sequence of flights such that
you take every flight exactly once, and end up at the place you
started.

</p><p> Analysis: This is equivalent to finding a Eulerian circuit in
a directed graph.

</p><h5>Cows on Parade</h5>

<p> Farmer John has two types of cows: black Angus and white Jerseys.
While marching 19 of their cows to market the other day, John's
wife Farmeress Joanne, noticed that all 16 possibilities of four
successive black and white cows (e.g., bbbb, bbbw, bbwb, bbww, ...,
wwww) were present.  Of course, some of the combinations overlapped
others.

</p><p> Given N (2 &lt;= N &lt;= 15), find the minimum length sequence of cows
such that every combination of N successive black and white cows occurs
in that sequence.

</p><p> Analysis:  The vertices of the graph are the possibilities of
N-1 cows.  Being at a node corresponds to the last N-1 cows matching
the node in color.  That is, for N = 4, if the last 3 cows were
<i>wbw</i>, then you are at the <i>wbw</i> node.  Each node has
out-degree of 2, corresponding to adding a black or white cow to
the end of the sequence.  In addition, each node has in-degree of
2, corresponding to whether the cow just before the last N-1 cows
is black or white.

</p><p> The graph is strongly connected, and the in-degree of each node
equals its out-degree, so the graph has a Eulerian circuit.

</p><p> The sequence corresponding to the Eulerian circuit is the
sequence of N-1 cows of the first node in the circuit, followed by
cows corresponding to the color of the edge.

</p><center>
<a href="http://train.usaco.org/usacogate?a=bhbgPYsGoPP">Back to USACO Training Gateway</a> | <a href="mailto:rob.kolstad@gmail.com">Comment or Question</a>
</center>
</div>

</font></body></html>
